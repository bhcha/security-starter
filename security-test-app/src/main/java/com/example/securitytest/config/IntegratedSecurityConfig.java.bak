package com.example.securitytest.config;

import com.dx.hexacore.security.auth.application.command.port.in.TokenManagementUseCase;
import com.dx.hexacore.security.auth.application.command.port.in.TokenValidationResult;
import com.dx.hexacore.security.auth.application.command.port.in.ValidateTokenCommand;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

/**
 * 통합 보안 설정 클래스
 * 
 * Spring Security와 Hexacore Security 라이브러리를 통합하여
 * 충돌 없이 함께 동작하도록 설정합니다.
 */
@Slf4j
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class IntegratedSecurityConfig {

    private final TokenManagementUseCase tokenManagementUseCase;

    /**
     * Spring Security 필터 체인 설정
     * 
     * 1. Hexacore Security 라이브러리의 JWT 토큰을 Spring Security가 인식하도록 설정
     * 2. API 엔드포인트별 접근 권한 설정
     * 3. 세션 정책: Stateless (JWT 토큰 기반)
     */
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // CSRF 비활성화 (JWT 토큰 사용)
            .csrf(csrf -> csrf.disable())
            
            // 세션 정책: Stateless
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            
            // URL별 접근 권한 설정
            .authorizeHttpRequests(auth -> auth
                // 인증 관련 엔드포인트는 모든 사용자 접근 허용
                .requestMatchers("/api/auth/**").permitAll()
                
                // Health check 엔드포인트
                .requestMatchers("/actuator/health").permitAll()
                
                // H2 콘솔 (개발환경에서만)
                .requestMatchers("/h2-console/**").permitAll()
                
                // Swagger/OpenAPI (있는 경우)
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                
                // 보호된 API 엔드포인트 - 인증 필요
                .requestMatchers("/api/protected/**").authenticated()
                
                // 관리자 전용 엔드포인트
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                
                // 나머지 모든 요청은 인증 필요
                .anyRequest().authenticated()
            )
            
            // H2 콘솔을 위한 프레임 옵션 설정
            .headers(headers -> headers.frameOptions().sameOrigin())
            
            // Hexacore Security JWT 토큰 인증 필터 추가
            .addFilterBefore(new HexacoreJwtAuthenticationFilter(tokenManagementUseCase), 
                           UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    /**
     * 비밀번호 암호화 설정
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 인증 매니저 설정
     */
    @Bean
    public AuthenticationManager authenticationManager(
            AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    /**
     * Hexacore Security의 JWT 토큰을 Spring Security Authentication으로 변환하는 필터
     */
    @Slf4j
    @RequiredArgsConstructor
    public static class HexacoreJwtAuthenticationFilter extends OncePerRequestFilter {

        private final TokenManagementUseCase tokenManagementUseCase;

        @Override
        protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                      FilterChain filterChain) throws ServletException, IOException {
            
            // Authorization 헤더에서 JWT 토큰 추출
            String authorizationHeader = request.getHeader("Authorization");
            
            if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
                String token = authorizationHeader.substring(7);
                
                try {
                    // Hexacore Security로 토큰 검증
                    ValidateTokenCommand command = new ValidateTokenCommand(token);
                    TokenValidationResult result = tokenManagementUseCase.validateToken(command);
                    
                    if (result.isValid()) {
                        // 유효한 토큰인 경우 Spring Security Authentication 생성
                        String username = result.getUsername();
                        
                        // 권한 설정 (실제 구현에서는 토큰에서 역할 정보 추출)
                        var authorities = Collections.singletonList(
                            new SimpleGrantedAuthority("ROLE_USER")
                        );
                        
                        Authentication authentication = new UsernamePasswordAuthenticationToken(
                            username, null, authorities
                        );
                        
                        // Spring Security Context에 인증 정보 설정
                        org.springframework.security.core.context.SecurityContextHolder
                            .getContext().setAuthentication(authentication);
                        
                        log.debug("Successfully authenticated user: {} with Hexacore JWT token", username);
                    } else {
                        log.debug("Invalid JWT token: {}", result.getInvalidReason().orElse("Unknown reason"));
                    }
                    
                } catch (Exception e) {
                    log.error("Error validating JWT token", e);
                }
            }
            
            // 다음 필터로 진행
            filterChain.doFilter(request, response);
        }
    }
}